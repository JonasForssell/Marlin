TODO: ------------------------------------------------
Prepare planner.cpp
Add A_AXIS, B_AXIS, C_AXIS, D_AXIS, EHP_AXIS as indices for all Hangprinter geometry arrays (still X_AXIS, Y_AXIS, Z_AXIS, E_AXIS for Carthesian geometry arrays)
  And add ABCDE and ABCDE_N wherever there was XYZE and XYZE_N before
  - stepper.cpp
  - Marlin_main.cpp

Map ABC D E axes to XYZ E1 E0

Change gcodes that look for axis_codes (= { 'X', 'Y', 'Z', 'E' }) so that they look for axis_codes_hangprinter (= { 'A', 'B', 'C', 'D', 'E' }) instead
  - M201
  - M204
  - M92

Include forward kinematics
  Use trilateration: https://en.wikipedia.org/wiki/Trilateration (Try all 4 combinations and average the result)

Make G6 and G1 S2 step individual motors

Make G28 do nothing but zero out counters

Implement M665 QWERTYUIOP in Marlin_main.cpp

Reorganize configuration_store so that MarlinSettings::load() and MarlinSettings::save() works
  - Make space for ABCDE arrays instead of XYZE arrays
  - Save anchor_A_y, anchor_B_x, ... in the 11 delta-floats

Make sure so that motors never disable when ENABLED(HANGPRINTER)

Include line buildup compensation

Include Mechaduino i2c code


DONE:-------------------------------------------------
Add HANGPRINTER define
Set sane defaults for Configuration.h
Add ANCHOR_ABC_XYZ and ANCHOR_D_Z
Include inverse kinematics
Prepare planner.h
Prepare planner.cpp


GENERAL STRATEGY:-------------------------------------
1: As small changes as possible
Changes analogous to DELTA
But don't use DELTA define or DELTA names. Use HANGPRINTER/KINEMATIC instead.

2: Use IS_KINEMATIC

3: Collect in arrays all that can be collected in arrays

4: Don't make new functions


QUESTIONS: -------------------------------------------
What is UBL, UBL_SEGMENTED etc ?
  ans: Unified Bed Leveling
  What does it do?
    Marlin uses ubl.prepare_segmented_line_to instead of prepare_kinematic_move_to if UBL_SEGMENTED is enabled...

Why does Marlin have #if ENABLED(DELTA_FAST_SQRT) in two places when there is no #define DELTA_FAST_SQRT?
  Don't use DELTA_FAST_SQRT/Q_rsqrt. It's the "Quake reciprocal sqrt"-trick.

Where is delta_segments_per_second initalized?
  Configuration_store.cpp?
  We should initialize anchor_ABCD_XYZ and other variables there as well

A comment in planner.h near planner.buffer_line() says:
"Kinematic machines should call buffer_line_kinematic (for leveled moves)."
But the DELTA code calls buffer_line(), not buffer_line_kinematic() (ok, it calls buffer_line_kinematic if there is no XY movement).

What is "fade"?

Why are ABC axes called ARG_X ARG_Y ARG_Z / rx ry rz?

Is target[] filled with target positions per motor before _buffer_steps() is called?
  A bitmap is created, and individual CORE_XY motors does not get directions directly from target[]. Rather X_HEAD is set directly from target[].
  DELTA is not mentioned at all....
  Ans: The function that calls _buffer_steps is buffer_segment. The description of buffer_segment says:
       "Leveling and kinematics should be applied ahead of calling this."

How to set XYZ_HEAD bits in _buffer_steps?
  Only abcd motor steps are known, and carthesian head movement should definitely be detemined from gcode, not from applying forward kinematics.
  How does DELTA do this?

The block->millimeters calculation on line 1111 of planner.cpp, is that millimeters of movement on each motor, or millimeters of effector movement?
  CORE machines treats it as millimeters of effector movement, DELTA treats it as millimeters of motor movement

OBSERVE: ---------------------------------------------
Hangprinter orders its arrays like A_AXIS, B_AXIS, C_AXIS, D_AXIS, EHP_AXIS
This affects ABCDE arrays
  - DEFAULT_AXIS_STEPS_PER_UNIT
  - DEFAULT_MAX_FEEDRATE
  - DEFAULT_MAX_ACCELERATION
  - homing_feedrate_mm_s[]
  - axis_steps_per_mm (planner.cpp)
  - steps_to_mm (planner.cpp)
  - max_acceleration_steps_per_s2 (planner.cpp)
  - max_acceleration_mm_per_s2 (planner.cpp)
  - block->steps[] (planner.cpp)
  - position[] (planner.cpp)
  - target[] (planner.cpp)
  - delta_mm[] (planner.cpp)
  - current_speed[] (planner.cpp)
  - max_jerk[] (planner.cpp)
  - previous_speed[] (planner.cpp)
  - position_float[] (planner.cpp)
  -
And ABCDE functions/methods
  - _buffer_steps (planner.cpp)
  - buffer_segment (planner.cpp)
  - _set_position_mm (planner.cpp)
  - buffer_line (planner.cpp)
And bitmaps
  - dm (planner.cpp)
  - block->direction_bits
  - old_direction_bits

And ABCD arrays
  - nr_of_lines_in_direction
  - MOUNTED_LINE
  - SPOOL_RADII
  - STEPS_PER_SPOOL_RADIAN

  Hangprinter mapping pins to axes:
  {X, Y, Z, E1, E0} <-> {A, B, C, D, E}
  Note that D axis uses the E1 pin

The following arrays are XYZE arrays
  - current_position[]
  - cart
  - raw


TODO LATER: ------------------------------------------
delta_segments_per_second -> kinematic_segments_per_second
Separating E_AXIS/EHP_AXIS and E_AXIS_N/EHP_AXIS_N with #if ENABLED(HANGPRINTER) is not pretty
  To find all occurences of [E_AXIS], except those in the file stepper.cpp, do
    grep -rn "\[E_AXIS\]" --exclude=stepper.cpp
  The problem is that sometimes you want to index [x,y,z,e]-arrays and sometimes [a,b,c,d,e]-arrays.
  Would be nice with a EXTRUDER_IN(array), EXTRUDER_N_IN(array) macro.
  How to tell the difference between a ABCDE-array and a XYZEE-array?
  One solution is if Marlin itself differentiates between arrays that hold cartesian(+e) axes data and
  those that hold movement axes data.
  The solution might be to define a E_INDEX_AUX in each file.
  Most XYZE-arrays seem to be in Marlin_main.cpp
  Most ABCDE-arrays seem to be in planner.cpp

The way that lin_dist_xy is calculated in stepper.cpp seems to assume a cartesian robot?
  Again, it seems like DELTA does nothing about this
